"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[4636],{17485:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=t(74848),r=t(28453);const s={title:"Seata's RPC Communication Source Code Analysis 02(Multi-Version Protocols)",author:"Xie Minghua",keywords:["Seata","RPC Module","Protocol"],date:"2024/08/15"},i="Seata's RPC Communication Source Code Analysis 02(Multi-Version Protocols)",a={permalink:"/blog/seata-rpc-multi-protocol02",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-rpc-multi-protocol02.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-rpc-multi-protocol02.md",title:"Seata's RPC Communication Source Code Analysis 02(Multi-Version Protocols)",description:"Overview",date:"2024-08-15T00:00:00.000Z",formattedDate:"August 15, 2024",tags:[],readingTime:7.83,hasTruncateMarker:!1,authors:[{name:"Xie Minghua"}],frontMatter:{title:"Seata's RPC Communication Source Code Analysis 02(Multi-Version Protocols)",author:"Xie Minghua",keywords:["Seata","RPC Module","Protocol"],date:"2024/08/15"},unlisted:!1,prevItem:{title:"Seata's RPC Communication Source Code Analysis 01(Transport)",permalink:"/blog/seata-rpc-multi-protocol01"},nextItem:{title:"How to Write Test Cases in Seata",permalink:"/blog/how-to-write-unit-tests"}},c={authorsImageUrls:[void 0]},l=[{value:"Overview",id:"overview",level:3},{value:"Structure of Protocol",id:"structure-of-protocol",level:2},{value:"From ByteBuf to RpcMessage (What the Encoder/Decoder Does)",id:"from-bytebuf-to-rpcmessage-what-the-encoderdecoder-does",level:2},{value:"Multi-version protocol (version recognition and binding)",id:"multi-version-protocol-version-recognition-and-binding",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:["In the previous article,",(0,o.jsx)(n.a,{href:"/blog/seata-rpc-multi-protocol01",children:"Seata's RPC Communication Source Code Analysis 01(Transport)"}),"we introduced the transmission mechanism of RPC communication. In this article, we will continue with the protocol part, completing the unaddressed encode/decode sections in the diagram."]}),"\n",(0,o.jsx)("img",{src:"/img/blog/rpc_multi-protocol/00-netty-layer.png",width:"700px"}),"\n",(0,o.jsx)(n.p,{children:"Similarly, we will delve into the topic using a question-driven approach. In this article, we aim not only to understand how binary data is parsed into the rpcMsg type but also to explore how different protocol versions are supported. So, the first question is: What does the protocol look like?"}),"\n",(0,o.jsx)(n.h2,{id:"structure-of-protocol",children:"Structure of Protocol"}),"\n",(0,o.jsx)("img",{src:"/img/blog/rpc_multi-protocol/04-protocol.jpg",width:"900px"}),"\n",(0,o.jsx)(n.p,{children:"The diagram illustrates the changes in the protocol before and after version 0.7.1 (you can also refer to the comments in ProtocolDecoderV1, and for older versions, check ProtocolV1Decoder). In the new version, the protocol consists of the following components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"magic-code: 0xdada"}),"\n",(0,o.jsx)(n.li,{children:"protocol-version: Version number"}),"\n",(0,o.jsx)(n.li,{children:"full-length: Total length"}),"\n",(0,o.jsx)(n.li,{children:"head-length: Header length"}),"\n",(0,o.jsx)(n.li,{children:"msgtype: Message type"}),"\n",(0,o.jsx)(n.li,{children:"serializer/codecType: Serialization method"}),"\n",(0,o.jsx)(n.li,{children:"compress: Compression method"}),"\n",(0,o.jsx)(n.li,{children:"requestid: Request ID"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Here, we will explain the differences in protocol handling across various versions of Seata's server:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["version",(0,o.jsx)(n.code,{children:"<"}),"0.7.1 : Can only handle the v0 version of the protocol (the upper part of the diagram, which includes the flag section) and cannot recognize other protocol versions."]}),"\n",(0,o.jsxs)(n.li,{children:["0.7.1",(0,o.jsx)(n.code,{children:"<="}),"version",(0,o.jsx)(n.code,{children:"<"}),"2.2.0 : Can only handle the v1 version of the protocol (the lower part of the diagram) and cannot recognize other protocol versions."]}),"\n",(0,o.jsxs)(n.li,{children:["version",(0,o.jsx)(n.code,{children:">="}),"2.2.0 : Can recognize and process both v0 and v1 versions of the protocol."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"So, how does version 2.2.0 achieve compatibility? Let's keep that a mystery for now. Before explaining this, let's first take a look at how the v1 encoder and decoder operate. It is important to note that, just like the transmission mechanism we discussed earlier, protocol handling is also shared between the client and server. Therefore, the logic we will discuss below applies to both."}),"\n",(0,o.jsx)(n.h2,{id:"from-bytebuf-to-rpcmessage-what-the-encoderdecoder-does",children:"From ByteBuf to RpcMessage (What the Encoder/Decoder Does)"}),"\n",(0,o.jsxs)(n.p,{children:["First",(0,o.jsx)(n.code,{children:"ProtocolDecoderV1"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'    public RpcMessage decodeFrame(ByteBuf frame) {\n        byte b0 = frame.readByte();\n        byte b1 = frame.readByte();\n\n        // get version\n        byte version = frame.readByte();\n        // get header,body,...\n        int fullLength = frame.readInt();\n        short headLength = frame.readShort();\n        byte messageType = frame.readByte();\n        byte codecType = frame.readByte();\n        byte compressorType = frame.readByte();\n        int requestId = frame.readInt();\n\n        ProtocolRpcMessageV1 rpcMessage = new ProtocolRpcMessageV1();\n        rpcMessage.setCodec(codecType);\n        rpcMessage.setId(requestId);\n        rpcMessage.setCompressor(compressorType);\n        rpcMessage.setMessageType(messageType);\n\n        // header\n        int headMapLength = headLength - ProtocolConstants.V1_HEAD_LENGTH;\n        if (headMapLength > 0) {\n            Map<String, String> map = HeadMapSerializer.getInstance().decode(frame, headMapLength);\n            rpcMessage.getHeadMap().putAll(map);\n        }\n\n        if (messageType == ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST) {\n            rpcMessage.setBody(HeartbeatMessage.PING);\n        } else if (messageType == ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) {\n            rpcMessage.setBody(HeartbeatMessage.PONG);\n        } else {\n            int bodyLength = fullLength - headLength;\n            if (bodyLength > 0) {\n                byte[] bs = new byte[bodyLength];\n                frame.readBytes(bs);\n                // According to the previously extracted compressorType, decompression is performed as needed.\n                Compressor compressor = CompressorFactory.getCompressor(compressorType);\n                bs = compressor.decompress(bs);\n                SerializerType protocolType = SerializerType.getByCode(rpcMessage.getCodec());\n                if (this.supportDeSerializerTypes.contains(protocolType)) {\n                    // Since this is the ProtocolDecoderV1 specifically for version 1, the serializer can directly use version1 as input.\n                    Serializer serializer = SerializerServiceLoader.load(protocolType, ProtocolConstants.VERSION_1);\n                    rpcMessage.setBody(serializer.deserialize(bs));\n                } else {\n                    throw new IllegalArgumentException("SerializerType not match");\n                }\n            }\n        }\n        return rpcMessage.protocolMsg2RpcMsg();\n    }\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Since the encode operation is the exact reverse of the decode operation, we won\u2019t go over it again. Let\u2019s continue by examining the serialize operation.\nthe serialize comes from ",(0,o.jsx)(n.code,{children:"SerializerServiceLoader"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'    public static Serializer load(SerializerType type, byte version) throws EnhancedServiceNotFoundException {\n        // PROTOBUF\n        if (type == SerializerType.PROTOBUF) {\n            try {\n                ReflectionUtil.getClassByName(PROTOBUF_SERIALIZER_CLASS_NAME);\n            } catch (ClassNotFoundException e) {\n                throw new EnhancedServiceNotFoundException("\'ProtobufSerializer\' not found. " +\n                        "Please manually reference \'org.apache.seata:seata-serializer-protobuf\' dependency ", e);\n            }\n        }\n\n        String key = serialzerKey(type, version);\n        //Here is a SERIALIZER_MAP, which acts as a cache for serializer classes. The reason for caching is that the scope of SeataSerializer is set to Scope.PROTOTYPE, which prevents the class from being created multiple times.\n        Serializer serializer = SERIALIZER_MAP.get(key);\n        if (serializer == null) {\n            if (type == SerializerType.SEATA) {\n                // SPI of seata\n                serializer = EnhancedServiceLoader.load(Serializer.class, type.name(), new Object[]{version});\n            } else {\n                serializer = EnhancedServiceLoader.load(Serializer.class, type.name());\n            }\n            SERIALIZER_MAP.put(key, serializer);\n        }\n        return serializer;\n    }\n\n    public SeataSerializer(Byte version) {\n        if (version == ProtocolConstants.VERSION_0) {\n            versionSeataSerializer = SeataSerializerV0.getInstance();\n        } else if (version == ProtocolConstants.VERSION_1) {\n            versionSeataSerializer = SeataSerializerV1.getInstance();\n        }\n        if (versionSeataSerializer == null) {\n            throw new UnsupportedOperationException("version is not supported");\n        }\n    }\n'})}),"\n",(0,o.jsxs)(n.p,{children:["With this, the decoder obtains a Serializer. When the program reaches",(0,o.jsx)(n.code,{children:"rpcMessage.setBody(serializer.deserialize(bs))"}),",\nlet's take a look at how the deserialize method processes the data."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"    public <T> T deserialize(byte[] bytes) {\n            return deserializeByVersion(bytes, ProtocolConstants.VERSION_0);\n    }\n    private static <T> T deserializeByVersion(byte[] bytes, byte version) {\n        //The previous part involves validity checks, which we will skip here.\n        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n        short typecode = byteBuffer.getShort();\n        ByteBuffer in = byteBuffer.slice();\n        //create Codec\n        AbstractMessage abstractMessage = MessageCodecFactory.getMessage(typecode);\n        MessageSeataCodec messageCodec = MessageCodecFactory.getMessageCodec(typecode, version);\n        //codec decode\n        messageCodec.decode(abstractMessage, in);\n        return (T) abstractMessage;\n    }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This serialize does not contain much logic, the key components is in the MessageCodecFactory and Codec, let's delve deeper.\nYou can see that ",(0,o.jsx)(n.code,{children:"MessageCodecFactory"})," has quite a lot of content, but in a single form, they all return message and codec according to MessageType,\nso we won't show the content of factory here, we will directly look at message and codec, that is, ",(0,o.jsx)(n.code,{children:"messageCodec.decode( abstractMessage, in)"}),",\nalthough there are still a lot of codec types, but we can see that their structure is similar, parsing each field:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"    // BranchRegisterRequestCodec decode\n    public <T> void decode(T t, ByteBuffer in) {\n        BranchRegisterRequest branchRegisterRequest = (BranchRegisterRequest)t;\n\n        // get xid\n        short xidLen = in.getShort();\n        if (xidLen > 0) {\n            byte[] bs = new byte[xidLen];\n            in.get(bs);\n            branchRegisterRequest.setXid(new String(bs, UTF8));\n        }\n        // get branchType\n        branchRegisterRequest.setBranchType(BranchType.get(in.get()));\n        short len = in.getShort();\n        if (len > 0) {\n            byte[] bs = new byte[len];\n            in.get(bs);\n            branchRegisterRequest.setResourceId(new String(bs, UTF8));\n        }\n        // get lockKey\n        int iLen = in.getInt();\n        if (iLen > 0) {\n            byte[] bs = new byte[iLen];\n            in.get(bs);\n            branchRegisterRequest.setLockKey(new String(bs, UTF8));\n        }\n        // get applicationData\n        int applicationDataLen = in.getInt();\n        if (applicationDataLen > 0) {\n            byte[] bs = new byte[applicationDataLen];\n            in.get(bs);\n            branchRegisterRequest.setApplicationData(new String(bs, UTF8));\n        }\n    }\n"})}),"\n",(0,o.jsx)(n.p,{children:"Well, by this point, we've got the branchRegisterRequest, which can be handed off to the TCInboundHandler for processing."}),"\n",(0,o.jsx)(n.p,{children:"But the problem is again, we only see the client (RM/TM) has the following kind of code to add encoder/decoder, that is, we know the client are using the current version of encoder/decoder processing:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"        bootstrap.handler(\n            new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(new IdleStateHandler(nettyClientConfig.getChannelMaxReadIdleSeconds(),nettyClientConfig.getChannelMaxWriteIdleSeconds(),nettyClientConfig.getChannelMaxAllIdleSeconds()))\n                        .addLast(new ProtocolDecoderV1())\n                        .addLast(new ProtocolEncoderV1());\n                    if (channelHandlers != null) {\n                        addChannelPipelineLast(ch, channelHandlers);\n                    }\n                }\n            });\n"})}),"\n",(0,o.jsx)(n.p,{children:"But how does server handle it? And what about the promised multi-version protocol?"}),"\n",(0,o.jsx)(n.h2,{id:"multi-version-protocol-version-recognition-and-binding",children:"Multi-version protocol (version recognition and binding)"}),"\n",(0,o.jsx)(n.p,{children:"Let's start by looking at a class diagram for encoder/decoder:"}),"\n",(0,o.jsx)("img",{src:"/img/blog/rpc_multi-protocol/05-encode-decode-class.jpg",width:"800px"}),"\n",(0,o.jsx)(n.p,{children:"ProtocolDecoderV1 we have analyzed, ProtocolEncoderV1 is the reverse operation, it should be better understood, as for ProtocolDecoderV0 and ProtocolEncoderV0, from the diagram you can also see that they are in parallel with v1, except for the operation of v0 (although so far we haven't put him to use yet), they are both subclasses of the typical encode and decode in netty, but what about MultiProtocolDecoder? He's the protagonist of the MultiProtocolDecoder and is registered into the server's bootstrap at startup."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'    protected boolean isV0(ByteBuf in) {\n        boolean isV0 = false;\n        in.markReaderIndex();\n        byte b0 = in.readByte();\n        byte b1 = in.readByte();\n        // In fact, identifying the protocol relies on the 3rd byte (b2), as long as it is a normal new version, b2 is the version number greater than 0. For versions below 0.7, b2 is the first bit of the FLAG, which just so happens to be 0 in either case!\n        // v1/v2/v3 : b2 = version\n        // v0 : b2 = 0 ,1st byte in FLAG(2byte:0x10/0x20/0x40/0x80)\n        byte b2 = in.readByte();\n        if (ProtocolConstants.MAGIC_CODE_BYTES[0] == b0 && ProtocolConstants.MAGIC_CODE_BYTES[1] == b1 && 0 == b2) {\n            isV0 = true;\n        }\n        // The read bytes have to be reset back in order for each version of the decoder to parse them from scratch.\n        in.resetReaderIndex();\n        return isV0;\n    }\n    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n        ByteBuf frame;\n        Object decoded;\n        byte version;\n        try {\n            // Identify the version number and get the current version number\n            if (isV0(in)) {\n                decoded = in;\n                version = ProtocolConstants.VERSION_0;\n            } else {\n                decoded = super.decode(ctx, in);\n                version = decideVersion(decoded);\n            }\n\n            if (decoded instanceof ByteBuf) {\n                frame = (ByteBuf) decoded;\n                ProtocolDecoder decoder = protocolDecoderMap.get(version);\n                ProtocolEncoder encoder = protocolEncoderMap.get(version);\n                try {\n                    if (decoder == null || encoder == null) {\n                        throw new UnsupportedOperationException("Unsupported version: " + version);\n                    }\n                    // First time invoke ,use a well-judged decoder for the operation\n                    return decoder.decodeFrame(frame);\n                } finally {\n                    if (version != ProtocolConstants.VERSION_0) {\n                        frame.release();\n                    }\n                    // First time invoke , bind the encoder and decoder corresponding to the version, which is equivalent to binding the channel\n                    ctx.pipeline().addLast((ChannelHandler)decoder);\n                    ctx.pipeline().addLast((ChannelHandler)encoder);\n                    if (channelHandlers != null) {\n                        ctx.pipeline().addLast(channelHandlers);\n                    }\n                    // After binding, remove itself and do not judge it subsequently\n                    ctx.pipeline().remove(this);\n                }\n            }\n        } catch (Exception exx) {\n            LOGGER.error("Decode frame error, cause: {}", exx.getMessage());\n            throw new DecodeException(exx);\n        }\n        return decoded;\n    }\n\n    protected byte decideVersion(Object in) {\n        if (in instanceof ByteBuf) {\n            ByteBuf frame = (ByteBuf) in;\n            frame.markReaderIndex();\n            byte b0 = frame.readByte();\n            byte b1 = frame.readByte();\n            if (ProtocolConstants.MAGIC_CODE_BYTES[0] != b0 || ProtocolConstants.MAGIC_CODE_BYTES[1] != b1) {\n                throw new IllegalArgumentException("Unknown magic code: " + b0 + ", " + b1);\n            }\n\n            byte version = frame.readByte();\n            frame.resetReaderIndex();\n            return version;\n        }\n        return -1;\n    }\n'})}),"\n",(0,o.jsx)(n.p,{children:"With the above analysis, v0 finally comes in handy (when a client with an older version registers,\nthe server assigns it a lower version of encoder/decoder), and we've figured out how multi-version protocols are recognized and bound."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);